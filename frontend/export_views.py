from django.utils import timezone
from datetime import datetime, timedelta
from django.contrib.auth.decorators import login_required
import calendar
from django.db import models
from django.db.models import Sum, Count, F, Avg, Min, Max
from products.models import Product, Category
import json
from django.template.loader import render_to_string
import weasyprint
import io
from django.http import JsonResponse, HttpResponse
from transactions.models import Transaction, InventoryLot, Trip, PurchaseOrder
from vessels.models import Vessel
from .utils.exports import ExcelExporter
from .utils.weasy_exporter import create_weasy_exporter_for_data, create_weasy_exporter
from django.views.decorators.http import require_http_methods
from django.shortcuts import get_object_or_404
import logging
from openpyxl.utils import get_column_letter
from openpyxl.styles import Font, PatternFill, Alignment
from collections import defaultdict
from .utils.helpers import (format_currency,
    format_currency_or_none,
    format_percentage,
    format_negative_if_supply,
    get_fifo_cost_for_transfer,
    calculate_transfer_amounts,
    calculate_totals_by_type,
    calculate_product_level_summary,
    translate_numbers_to_arabic,
    get_vessel_name_by_language,
    format_date_for_language,
    format_datetime_for_language,
    safe_float,
    safe_int,
    format_date,
    get_date_range_from_request,
    create_safe_response
    )

# Set up logging
logger = logging.getLogger(__name__)

def get_vessel_name_by_language_data(name_en, name_ar, language):
    """Get vessel name in appropriate language from data"""
    if language == 'ar' and name_ar:
        return name_ar
    return name_en

def get_translated_labels(request, data=None):
    """Get comprehensive translated labels for exports with cart verification support"""
    user_language = 'en'
    
    if hasattr(request, 'session') and 'preferred_language' in request.session:
        user_language = request.session['preferred_language']
    elif data and 'language' in data:
        user_language = data['language']
    elif 'HTTP_X_USER_LANGUAGE' in request.META:
        user_language = request.META['HTTP_X_USER_LANGUAGE']
    
    translations = {
        'en': {
            # Basic export terms
            'export_date': 'Export Date',
            'generated_on': 'Generated on',
            'generated_by': 'Generated By',
            'report_information': 'Report Information',
            'summary': 'Summary',
            'company_logo': 'COMPANY LOGO',
            'no_data_available': 'No data available',
            
            # PO specific terms
            'po_number': 'PO Number',
            'po_date': 'PO Date',
            'vessel': 'Vessel',
            'status': 'Status',
            'notes': 'Notes',
            'completed': 'Completed',
            'pending': 'Pending',
            'in_progress': 'In Progress',
            'auto_generated': 'Auto Generated',
            
            # Verification specific terms
            'verification_report': 'Verification Report',
            'auto_export': 'Auto-Export',
            'financial_verification_report': 'FINANCIAL VERIFICATION REPORT',
            'verification_instructions': 'This report is designed for financial department review and approval. Please verify all calculations against supplier invoice.',
            'received_items_summary': 'RECEIVED ITEMS SUMMARY',
            'verification_calculations': 'VERIFICATION CALCULATIONS',
            'financial_summary': 'FINANCIAL SUMMARY',
            'review_alerts': 'REVIEW ALERTS',
            'finance_checklist': 'FINANCE DEPARTMENT CHECKLIST',
            'approvals': 'APPROVALS',
            
            # Table headers
            'time': 'Time',
            'product': 'Product',
            'product_id': 'Product ID',
            'quantity': 'Quantity',
            'quantity_breakdown': 'Quantity Breakdown',
            'unit_cost': 'Unit Cost',
            'unit_cost_calculated': 'Unit Cost (Calculated)',
            'total_cost': 'Total Cost',
            'total_cost_jod': 'Total Cost (JOD)',
            'invoice_amount': 'Invoice Amount',
            'verification_status': 'Verification Status',
            'calculation': 'Calculation',
            'result': 'Result',
            
            # Units and measurements
            'units': 'units',
            'units_total': 'units total',
            'per_unit': 'per unit',
            'boxes': 'boxes',
            'products': 'products',
            'items': 'items',
            'jod': 'JOD',
            'jod_currency': 'JOD',
            
            # Status messages
            'normal': 'Normal',
            'high_cost': 'High Cost',
            'low_cost': 'Low Cost',
            'flagged_items': 'flagged items',
            'alerts': 'alerts',
            'all_items_normal': 'All items within normal range',
            'no_alerts': 'No cost variance alerts - all items within normal pricing range',
            
            # Summary fields
            'total_products': 'Total Products',
            'total_items': 'Total Items',
            'total_quantity': 'Total Quantity',
            'total_items_received': 'Total Items Received',
            'average_cost_per_unit': 'Average Cost per Unit',
            'average_cost_per_item_jod': 'Average Cost per Item (JOD)',
            'verification_alerts': 'Verification Alerts',
            'export_type': 'Export Type',
            'total_verification': 'TOTAL VERIFICATION',
            'sum_all_calculations': 'Sum of all calculations',
            
            # Checklist items
            'checklist_invoice_match': 'Invoice amount matches system total',
            'checklist_quantities': 'Product quantities verified against physical count',
            'checklist_costs': 'Unit costs reviewed and approved',
            'checklist_alerts': 'All verification alerts investigated and resolved',
            'checklist_invoice_attached': 'Supplier invoice attached to this report',
            'checklist_journal': 'Journal entry created in accounting system',
            'checklist_filing': 'Purchase order filed in procurement records',
            
            # Signature fields
            'completed_by': 'Completed by',
            'reviewed_by': 'Reviewed by',
            'approved_by': 'Approved by',
            'date': 'Date',
            
            # Footer
            'system_generated': 'This is a system-generated document for financial verification purposes',
            'system_name': 'Generated by Vessel Management System v2.1'
        },
        'ar': {
            # Basic export terms
            'export_date': 'تاريخ التصدير',
            'generated_on': 'تم إنشاؤه في',
            'generated_by': 'تم إنشاؤه بواسطة',
            'report_information': 'معلومات التقرير',
            'summary': 'الملخص',
            'company_logo': 'شعار الشركة',
            'no_data_available': 'لا توجد بيانات متاحة',
            
            # PO specific terms
            'po_number': 'رقم أمر الشراء',
            'po_date': 'تاريخ أمر الشراء',
            'vessel': 'السفينة',
            'status': 'الحالة',
            'notes': 'ملاحظات',
            'completed': 'مكتمل',
            'pending': 'معلق',
            'in_progress': 'قيد التنفيذ',
            'auto_generated': 'تصدير تلقائي',
            
            # Verification specific terms
            'verification_report': 'تقرير التحقق',
            'auto_export': 'تصدير تلقائي',
            'financial_verification_report': 'تقرير التحقق المالي',
            'verification_instructions': 'هذا التقرير مصمم لمراجعة وموافقة القسم المالي. يرجى التحقق من جميع الحسابات مقابل فاتورة المورد.',
            'received_items_summary': 'ملخص العناصر المستلمة',
            'verification_calculations': 'حسابات التحقق',
            'financial_summary': 'الملخص المالي',
            'review_alerts': 'تنبيهات المراجعة',
            'finance_checklist': 'قائمة التحقق للقسم المالي',
            'approvals': 'الموافقات',
            
            # Table headers
            'time': 'الوقت',
            'product': 'المنتج',
            'product_id': 'رقم المنتج',
            'quantity': 'الكمية',
            'quantity_breakdown': 'تقسيم الكمية',
            'unit_cost': 'تكلفة الوحدة',
            'unit_cost_calculated': 'تكلفة الوحدة (محسوبة)',
            'total_cost': 'التكلفة الإجمالية',
            'total_cost_jod': 'التكلفة الإجمالية (دينار أردني)',
            'invoice_amount': 'مبلغ الفاتورة',
            'verification_status': 'حالة التحقق',
            'calculation': 'الحساب',
            'result': 'النتيجة',
            
            # Units and measurements
            'units': 'وحدات',
            'units_total': 'وحدات إجمالي',
            'per_unit': 'لكل وحدة',
            'boxes': 'صناديق',
            'products': 'منتجات',
            'items': 'عناصر',
            'jod': 'دينار أردني',
            'jod_currency': 'دينار أردني',
            
            # Status messages
            'normal': 'عادي',
            'high_cost': 'تكلفة عالية',
            'low_cost': 'تكلفة منخفضة',
            'flagged_items': 'عناصر مُعلمة',
            'alerts': 'تنبيهات',
            'all_items_normal': 'جميع العناصر ضمن النطاق العادي',
            'no_alerts': 'لا توجد تنبيهات انحراف في التكلفة - جميع العناصر ضمن النطاق السعري العادي',
            
            # Summary fields
            'total_products': 'إجمالي المنتجات',
            'total_items': 'إجمالي العناصر',
            'total_quantity': 'الكمية الإجمالية',
            'total_items_received': 'إجمالي العناصر المستلمة',
            'average_cost_per_unit': 'متوسط التكلفة لكل وحدة',
            'average_cost_per_item_jod': 'متوسط التكلفة لكل عنصر (دينار أردني)',
            'verification_alerts': 'تنبيهات التحقق',
            'export_type': 'نوع التصدير',
            'total_verification': 'إجمالي التحقق',
            'sum_all_calculations': 'مجموع جميع الحسابات',
            
            # Checklist items
            'checklist_invoice_match': 'مبلغ الفاتورة يطابق إجمالي النظام',
            'checklist_quantities': 'تم التحقق من كميات المنتجات مقابل العد الفعلي',
            'checklist_costs': 'تمت مراجعة وموافقة تكاليف الوحدة',
            'checklist_alerts': 'تم التحقيق في جميع تنبيهات التحقق وحلها',
            'checklist_invoice_attached': 'تم إرفاق فاتورة المورد بهذا التقرير',
            'checklist_journal': 'تم إنشاء قيد اليومية في نظام المحاسبة',
            'checklist_filing': 'تم حفظ أمر الشراء في سجلات المشتريات',
            
            # Signature fields
            'completed_by': 'أُكمل بواسطة',
            'reviewed_by': 'رُوجع بواسطة',
            'approved_by': 'وُوفق بواسطة',
            'date': 'التاريخ',
            
            # Footer
            'system_generated': 'هذه وثيقة منتجة بواسطة النظام لأغراض التحقق المالي',
            'system_name': 'تم إنشاؤه بواسطة نظام إدارة السفن الإصدار 2.1'
        }
    }
    
    labels = translations.get(user_language, translations['en'])
    labels['language'] = user_language
    return labels



# ===============================================================================
# INVENTORY EXPORT
# ===============================================================================

@login_required
@require_http_methods(["POST"])
def export_inventory(request):
    """OPTIMIZED: Export current inventory status with database aggregations"""
    try:
        data = json.loads(request.body)
        export_format = data.get('format', 'excel')
        
        # Get translated labels with language from request
        labels = get_translated_labels(request, data)
        language = labels['language']
        
        # Get filters
        vessel_id = data.get('vessel_id')
        category_id = data.get('category_id')
        low_stock_only = data.get('low_stock_only', False)
        
        # OPTIMIZED: Single query with all aggregations and relations
        inventory_query = InventoryLot.objects.filter(
            remaining_quantity__gt=0  # Only active inventory
        ).select_related(
            'product', 'product__category', 'vessel'
        )
        
        # Apply filters
        if vessel_id:
            inventory_query = inventory_query.filter(vessel_id=vessel_id)
        if category_id:
            inventory_query = inventory_query.filter(product__category_id=category_id)
        
        # OPTIMIZED: Aggregate by product and vessel in the database
        inventory_aggregated = inventory_query.values(
            'product__id',
            'product__name', 
            'product__item_id',
            'product__category__name',
            'vessel__id',
            'vessel__name', 
            'vessel__name_ar'
        ).annotate(
            total_quantity=Sum('remaining_quantity'),
            fifo_cost=Min('purchase_price'),  # FIFO: oldest (cheapest) cost
            latest_update=Max('created_at'),
            total_value=Sum(F('remaining_quantity') * F('purchase_price'), output_field=models.DecimalField())
        ).order_by('product__name', 'vessel__name')
        
        # OPTIMIZED: Calculate summary statistics in the database
        summary_stats = inventory_aggregated.aggregate(
            total_products=Count('product__id', distinct=True),
            total_inventory_value=Sum('total_value'),
            total_quantity_all=Sum('total_quantity'),
            avg_value_per_item=Avg('total_value')
        )
        
        # Apply low stock filter if requested
        if low_stock_only:
            inventory_aggregated = inventory_aggregated.filter(total_quantity__lte=5)
        
        # OPTIMIZED: Build export data efficiently
        inventory_data = []
        for item in inventory_aggregated:
            # Get vessel name in appropriate language
            vessel_name = get_vessel_name_by_language_data(
                item['vessel__name'], 
                item['vessel__name_ar'], 
                language
            )
            
            # Format data for export
            formatted_data = [
                item['product__name'],
                item['product__item_id'],
                item['product__category__name'] or labels.get('uncategorized', 'Uncategorized'),
                vessel_name,
                translate_numbers_to_arabic(format_currency(item['total_quantity'], 0), language),
                translate_numbers_to_arabic(format_currency(item['fifo_cost'], 3), language),
                translate_numbers_to_arabic(format_currency(item['total_value'], 3), language),
                format_datetime_for_language(item['latest_update'], language) if item['latest_update'] else '-'
            ]
            inventory_data.append(formatted_data)
        
        # Calculate low stock and out of stock counts
        low_stock_count = len([item for item in inventory_aggregated if item['total_quantity'] <= 5])
        
        # Get out of stock products (products that exist but have zero inventory)
        out_of_stock_query = Product.objects.filter(active=True)
        if vessel_id:
            out_of_stock_query = out_of_stock_query.filter(
                inventory_lots__vessel_id=vessel_id
            )
        if category_id:
            out_of_stock_query = out_of_stock_query.filter(category_id=category_id)
            
        out_of_stock_count = out_of_stock_query.exclude(
            inventory_lots__remaining_quantity__gt=0
        ).distinct().count()
        
        # Generate filename
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename_base = f"inventory_export_{timestamp}"
        
        # Get current datetime for metadata
        local_dt = timezone.localtime(timezone.now()).replace(tzinfo=None)
        
        # OPTIMIZED: Build metadata with calculated values
        metadata = {
            labels['export_date']: format_datetime_for_language(local_dt, language),
            labels['total_products']: translate_numbers_to_arabic(
                str(summary_stats['total_products'] or 0), language
            ),
            labels['currency']: labels['jod'],
            labels['total_value']: translate_numbers_to_arabic(
                format_currency(summary_stats['total_inventory_value'] or 0, 3), language
            ),
            labels['low_stock_items']: translate_numbers_to_arabic(str(low_stock_count), language),
            labels['out_of_stock_items']: translate_numbers_to_arabic(str(out_of_stock_count), language),
            labels['average_value_per_item']: translate_numbers_to_arabic(
                format_currency(summary_stats['avg_value_per_item'] or 0, 3), language
            ),
            labels['generated_by']: request.user.username,
            labels['vessel']: get_vessel_name_by_language(
                Vessel.objects.get(id=vessel_id) if vessel_id else None, language
            ) if vessel_id else labels.get('all', 'All'),
            labels.get('category', 'Category'): (
                Category.objects.get(id=category_id).name if category_id else labels.get('all', 'All')
            ),
            labels['low_stock_filter']: labels['yes'] if low_stock_only else labels['no']
        }
        
        # Headers with translation
        headers = [
            labels['product_name'],
            labels['product_id'],
            labels['category'],
            labels['vessel'],
            labels['current_stock'],
            labels['unit_cost'],
            labels['total_value'],
            labels['last_updated']
        ]
        
        # Generate report title
        report_title = labels['inventory_report']
        
        if export_format == 'excel':
            try:
                exporter = ExcelExporter(title=report_title)
                
                generation_text = f"{labels['generated_on']} {format_datetime_for_language(local_dt, language)}"
                exporter.add_title(report_title, generation_text)
                exporter.add_metadata(metadata)
                exporter.add_headers(headers)
                exporter.add_data_rows(inventory_data)
                
                return exporter.get_response(f"{filename_base}.xlsx")
                
            except Exception as e:
                logger.error(f"Excel inventory export error: {e}")
                return JsonResponse({'success': False, 'error': f'Excel export failed: {str(e)}'})
        
        else:  # PDF
            try:
                # Create context for PDF
                context = {
                    'title': report_title,
                    'metadata': metadata,
                    'tables': [{
                        'title': f"{report_title} - {labels['current_inventory']}", 
                        'id': 'inventory_table', 
                        'headers': headers, 
                        'rows': inventory_data
                    }],
                    'orientation': 'landscape',
                    'language': language,
                    'generation_date': format_datetime_for_language(local_dt, language),
                    'has_logo': False,
                    'generated_on_text': labels['generated_on'],
                    'report_info_text': labels['report_information'],
                    'summary_text': labels['summary'],
                    'company_logo_text': labels['company_logo'],
                    'no_data_text': labels['no_data_available'],
                }
                
                template_name = 'frontend/exports/wide_report.html'
                html_string = render_to_string(template_name, context)
                
                html = weasyprint.HTML(string=html_string)
                
                buffer = io.BytesIO()
                html.write_pdf(target=buffer)
                buffer.seek(0)
                
                response = HttpResponse(content_type='application/pdf')
                response['Content-Disposition'] = f'attachment; filename="{filename_base}.pdf"'
                response['Content-Length'] = len(buffer.getvalue())
                response.write(buffer.getvalue())
                
                return response
                
            except Exception as e:
                logger.error(f"PDF inventory export error: {e}")
                return JsonResponse({'success': False, 'error': f'PDF export failed: {str(e)}'})
                
    except json.JSONDecodeError:
        return JsonResponse({'success': False, 'error': 'Invalid JSON data'})
    except Exception as e:
        logger.error(f"Inventory export error: {e}")
        return JsonResponse({'success': False, 'error': f'Export failed: {str(e)}'})

# ===============================================================================
# TRANSACTION EXPORTS
# ===============================================================================

@login_required
@require_http_methods(["POST"])
def export_transactions(request):
    """Export transactions to Excel or PDF with comprehensive filtering"""
    try:
        data = json.loads(request.body)
        export_format = data.get('format', 'excel')
        
        # Get filters
        start_date, end_date = get_date_range_from_request(data)
        if not start_date or not end_date:
            return JsonResponse({'success': False, 'error': 'Invalid date range'})
            
        vessel_id = data.get('vessel_id')
        transaction_type = data.get('transaction_type')
        product_id = data.get('product_id')
        
        # Build query with proper field names
        transactions = Transaction.objects.select_related(
            'vessel', 'product', 'product__category', 'created_by', 'trip', 'purchase_order'
        ).filter(
            transaction_date__gte=start_date,
            transaction_date__lte=end_date
        ).order_by('-transaction_date')
        
        # Apply filters
        if vessel_id:
            transactions = transactions.filter(vessel_id=vessel_id)
        if transaction_type:
            transactions = transactions.filter(transaction_type=transaction_type)
        if product_id:
            transactions = transactions.filter(product_id=product_id)
            
        # Calculate totals by type
        transaction_list = list(transactions[:5000])  # Limit to prevent memory issues
        totals_by_type = calculate_totals_by_type(transaction_list)
        
        # Prepare table data with new formatting
        table_data = []
        
        for transaction in transaction_list:
            # Calculate amounts based on transaction type
            if transaction.transaction_type in ['TRANSFER_OUT', 'TRANSFER_IN']:
                amount = calculate_transfer_amounts(transaction)
            else:
                amount = safe_float(transaction.quantity) * safe_float(transaction.unit_price)
            
            # Determine Unit Cost and Unit Price based on transaction type
            unit_cost = None
            unit_price = None
            
            if transaction.transaction_type == 'SALE':
                unit_price = safe_float(transaction.unit_price)
                # For sales, unit cost would be the FIFO cost (if available)
                # For now, we'll leave unit_cost as None for sales
            elif transaction.transaction_type == 'SUPPLY':
                unit_cost = safe_float(transaction.unit_price)
                # For supplies, unit_price is None
            elif transaction.transaction_type == 'TRANSFER_OUT':
                # For transfer out, use FIFO cost as unit_cost
                fifo_cost = get_fifo_cost_for_transfer(transaction.vessel, transaction.product, transaction.quantity)
                unit_cost = fifo_cost
            elif transaction.transaction_type == 'TRANSFER_IN':
                # For transfer in, use the same cost as the related transfer out
                if hasattr(transaction, 'related_transfer') and transaction.related_transfer:
                    fifo_cost = get_fifo_cost_for_transfer(transaction.related_transfer.vessel, transaction.product, transaction.quantity)
                    unit_cost = fifo_cost
            
            # Format amounts (negative for supplies and transfer ins)
            formatted_amount = format_negative_if_supply(amount, transaction.transaction_type)
            
            # Format vessel, product names (remove N/A)
            vessel_name = transaction.vessel.name if transaction.vessel else None
            product_name = transaction.product.name if transaction.product else None
            category_name = transaction.product.category.name if transaction.product and transaction.product.category else None
            trip_number = transaction.trip.trip_number if transaction.trip else None
            po_number = transaction.purchase_order.po_number if transaction.purchase_order else None
            created_by = transaction.created_by.username if transaction.created_by else None
            notes = transaction.notes if transaction.notes else None
            
            table_data.append([
                format_date(transaction.transaction_date),
                transaction.get_transaction_type_display() if hasattr(transaction, 'get_transaction_type_display') else transaction.transaction_type,
                vessel_name,
                product_name,
                category_name,
                format_currency(transaction.quantity, 3),
                format_currency_or_none(unit_price, 3),  # Unit Price
                format_currency_or_none(unit_cost, 3),   # Unit Cost  
                formatted_amount,  # Total Amount (negative for supplies)
                trip_number,
                po_number,
                created_by,
                notes
            ])
        
        # Generate filename
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename_base = f"transactions_export_{timestamp}"
        
        # Metadata with split totals
        metadata = {
            'Export Date': datetime.now().strftime('%d/%m/%Y %H:%M'),
            'Date Range': f"{format_date(start_date)} to {format_date(end_date)}",
            'Total Records': len(table_data),
            'Total Sales (JOD)': format_currency(totals_by_type['total_sales'], 3),
            'Total Supplies (JOD)': f"({format_currency(totals_by_type['total_supplies'], 3)})",
            'Total Transfers (JOD)': format_currency(totals_by_type['total_transfers'], 3),
            'Generated By': request.user.username,
            'Filters Applied': f"Vessel: {vessel_id or 'All'}, Type: {transaction_type or 'All'}, Product: {product_id or 'All'}"
        }
        
        headers = [
            'Date', 'Type', 'Vessel', 'Product', 'Category', 
            'Quantity', 'Unit Price (JOD)', 'Unit Cost (JOD)', 'Total Amount (JOD)', 
            'Trip #', 'PO #', 'Created By', 'Notes'
        ]
        
        # Create product-level summary (replaces redundant summary)
        product_summary = calculate_product_level_summary(transaction_list)
        
        if export_format == 'excel':
            try:
                exporter = ExcelExporter(title="Transactions Export")
                exporter.add_title("Transactions Report", f"Generated on {datetime.now().strftime('%d/%m/%Y %H:%M')}")
                exporter.add_metadata(metadata)
                exporter.add_headers(headers)
                exporter.add_data_rows(table_data)
                
                # Only add product summary if we have data and it's not the same as metadata
                if product_summary and len(product_summary) > 0:
                    # Add spacing
                    exporter.current_row += 1
                    
                    # Add product summary title
                    exporter.worksheet[f'A{exporter.current_row}'] = "Product Summary"
                    exporter.worksheet[f'A{exporter.current_row}'].font = Font(size=14, bold=True, color="2C3E50")
                    
                    # Merge across all columns
                    if exporter.header_count > 1:
                        end_column = get_column_letter(exporter.header_count)
                        try:
                            exporter.worksheet.merge_cells(f'A{exporter.current_row}:{end_column}{exporter.current_row}')
                        except:
                            pass
                    
                    exporter.current_row += 1
                    
                    # Add product summary headers
                    summary_headers = ['Item Name', 'Item ID', 'Qty Supplied', 'Qty Sold', 'Total Cost', 'Total Revenue', 'Net Profit']
                    for col_idx, header in enumerate(summary_headers, 1):
                        cell = exporter.worksheet.cell(row=exporter.current_row, column=col_idx, value=header)
                        cell.font = exporter.header_font
                        cell.alignment = exporter.header_alignment
                        cell.fill = PatternFill(start_color="E3F2FD", end_color="E3F2FD", fill_type="solid")
                        cell.border = exporter.border
                    
                    exporter.current_row += 1
                    
                    # Add product summary data
                    for row in product_summary:
                        for col_idx, value in enumerate(row, 1):
                            cell = exporter.worksheet.cell(row=exporter.current_row, column=col_idx, value=value)
                            cell.border = exporter.border
                            if col_idx >= 3:  # Numeric columns
                                cell.alignment = Alignment(horizontal='right', vertical='center')
                        exporter.current_row += 1
                
                return exporter.get_response(f"{filename_base}.xlsx")
                
            except Exception as e:
                logger.error(f"Excel export error: {e}")
                return JsonResponse({'success': False, 'error': f'Excel export failed: {str(e)}'})
        
        else:  # PDF
            try:
                exporter = create_weasy_exporter_for_data("Transactions Report", "wide")
                exporter.add_metadata(metadata)
                exporter.add_table(headers, table_data, table_title="Transaction History")
                
                # Add product summary instead of redundant summary
                if product_summary and len(product_summary) > 0:
                    summary_headers = ['Item Name', 'Item ID', 'Qty Supplied', 'Qty Sold', 'Total Cost', 'Total Revenue', 'Net Profit']
                    exporter.add_table(summary_headers, product_summary, table_title="Product Summary")
                
                return exporter.get_response(f"{filename_base}.pdf")
                
            except Exception as e:
                logger.error(f"PDF export error: {e}")
                return JsonResponse({'success': False, 'error': f'PDF export failed: {str(e)}'})
                
    except json.JSONDecodeError:
        return JsonResponse({'success': False, 'error': 'Invalid JSON data'})
    except Exception as e:
        logger.error(f"Transaction export error: {e}")
        return JsonResponse({'success': False, 'error': f'Export failed: {str(e)}'})

# ===============================================================================
# TRIP EXPORTS (LIST AND INDIVIDUAL)
# ===============================================================================

@login_required
@require_http_methods(["POST"])
def export_trips(request):
    """Export trips list to Excel or PDF - Fixed with RTL support following individual export pattern"""
    try:
        data = json.loads(request.body)
        export_format = data.get('format', 'excel')
        
        # Get translated labels with language from request (for RTL support)
        labels = get_translated_labels(request, data)
        language = labels['language']
        
        # Get filters
        start_date, end_date = get_date_range_from_request(data)
        if not start_date or not end_date:
            return JsonResponse({'success': False, 'error': 'Invalid date range'})
            
        vessel_id = data.get('vessel_id')
        status = data.get('status')
        
        # Build query
        trips = Trip.objects.select_related(
            'vessel', 'created_by'
        ).filter(
            trip_date__gte=start_date,
            trip_date__lte=end_date
        ).order_by('-trip_date')
        
        # Apply filters
        if vessel_id:
            trips = trips.filter(vessel_id=vessel_id)
        if status:
            trips = trips.filter(status=status)
            
        # Prepare data
        table_data = []
        total_revenue = 0
        
        for trip in trips[:2000]:
            # Calculate trip financials
            trip_revenue = Transaction.objects.filter(
                trip=trip,
                transaction_type='SALE'
            ).aggregate(
                total=Sum(F('quantity') * F('unit_price'))
            )['total'] or 0
            
            total_revenue += trip_revenue
            
             # Get transaction count
            transaction_count = Transaction.objects.filter(trip=trip).count()
                        
            # Get vessel name in appropriate language
            vessel_name = get_vessel_name_by_language(trip.vessel, language)
            
            # Format data with number translation for Arabic
            trip_status_key = 'completed' if getattr(trip, 'is_completed', False) or getattr(trip, 'status', '') == 'completed' else 'pending'
            trip_status = labels[trip_status_key]
            
            # Get current datetime for trip date metadata formatting
            local_dt = timezone.localtime(trip.created_at).replace(tzinfo=None) if hasattr(trip, 'created_at') else timezone.now().replace(tzinfo=None)
            
            formatted_data = [
                translate_numbers_to_arabic(str(trip.trip_number), language),
                vessel_name,
                format_date_for_language(local_dt, language),
                trip_status,
                translate_numbers_to_arabic(format_currency(trip_revenue, 3), language),
                translate_numbers_to_arabic(str(safe_int(transaction_count)), language),
                translate_numbers_to_arabic(str(safe_int(getattr(trip, 'passenger_count', 0))), language),
                trip.created_by.username if trip.created_by else 'N/A'
            ]
            table_data.append(formatted_data)
        
        # Generate filename
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename_base = f"trips_export_{timestamp}"
        
        # Metadata with translation
        metadata = {
            labels['export_date']: format_datetime_for_language(datetime.now(), language),
            labels['period']: f"{format_date_for_language(start_date, language)} - {format_date_for_language(end_date, language)}",
            labels['total_trips']: translate_numbers_to_arabic(str(len(table_data)), language),
            labels['total_revenue_jod']: translate_numbers_to_arabic(format_currency(total_revenue, 3), language),
            labels['currency']: labels['jod'],  # Apply new currency pattern
            labels['average_per_trip']: translate_numbers_to_arabic(format_currency((total_revenue / len(table_data)) if table_data else 0, 3), language),
            labels['generated_by']: request.user.username
        }
        
        # Headers with translation
        headers = [
            labels['trip_number'],
            labels['vessel'],
            labels['trip_date'],
            labels['status'],
            labels['total_revenue_jod'],
            labels.get('transactions', 'Transactions'),
            labels['passengers'],
            labels['generated_by']
        ]
        
        # Summary data with translation
        summary_data = {
            labels['total_trips']: translate_numbers_to_arabic(str(len(table_data)), language),
            labels['total_revenue_jod']: translate_numbers_to_arabic(format_currency(total_revenue, 3), language),
            labels['average_per_trip']: translate_numbers_to_arabic(format_currency((total_revenue / len(table_data)) if table_data else 0, 3), language),
            labels['currency']: labels['jod']
        }
        
        # Generate report title with translation
        if language == 'ar':
            report_title = labels['trips_report']
        else:
            report_title = labels['trips_report']
        
        if export_format == 'excel':
            try:
                exporter = ExcelExporter(title=report_title)
                
                generation_text = f"{labels['generated_on']} {format_datetime_for_language(local_dt, language)}"
                exporter.add_title(report_title, generation_text)
                exporter.add_metadata(metadata)
                exporter.add_headers(headers)
                exporter.add_data_rows(table_data)
                exporter.add_summary(summary_data)
                
                return exporter.get_response(f"{filename_base}.xlsx")
                
            except Exception as e:
                logger.error(f"Excel trips export error: {e}")
                return JsonResponse({'success': False, 'error': f'Excel export failed: {str(e)}'})
        
        else:  # PDF - Use the SAME pattern as working individual exports
            try:
                # Create context manually like the working individual exports
                context = {
                    'title': report_title,
                    'metadata': metadata,
                    'tables': [{'title': f"{report_title} - {labels.get('trips_overview', 'Trips Overview')}", 'id': 'trips_table', 'headers': headers, 'rows': table_data}],
                    'summary_data': summary_data,
                    'orientation': 'landscape',
                    'language': language,  # KEY: This enables RTL
                    'generation_date': format_datetime_for_language(datetime.now(), language),
                    'has_logo': False,
                    'generated_on_text': labels['generated_on'],
                    'report_info_text': labels['report_information'],
                    'summary_text': labels['summary'],
                    'company_logo_text': labels['company_logo'],
                    'no_data_text': labels['no_data_available'],
                }
                
                # Use the same pattern as working individual exports
                
                
                template_name = 'frontend/exports/wide_report.html'
                html_string = render_to_string(template_name, context)
                
                html = weasyprint.HTML(string=html_string)
                
                buffer = io.BytesIO()
                html.write_pdf(target=buffer)
                buffer.seek(0)
                
                response = HttpResponse(content_type='application/pdf')
                response['Content-Disposition'] = f'attachment; filename="{filename_base}.pdf"'
                response['Content-Length'] = len(buffer.getvalue())
                response.write(buffer.getvalue())
                
                return response
                
            except Exception as e:
                logger.error(f"PDF trips export error: {e}")
                return JsonResponse({'success': False, 'error': f'PDF export failed: {str(e)}'})
                
    except json.JSONDecodeError:
        return JsonResponse({'success': False, 'error': 'Invalid JSON data'})
    except Exception as e:
        logger.error(f"Trips export error: {e}")
        return JsonResponse({'success': False, 'error': f'Export failed: {str(e)}'})

@login_required
@require_http_methods(["POST"])
def export_single_trip(request, trip_id):
    """Export individual trip details - Enhanced RTL support for metadata and summary sections"""
    try:
        data = json.loads(request.body)
        export_format = data.get('format', 'excel')
        
        # Get translated labels with language from request
        labels = get_translated_labels(request, data)
        language = labels['language']
        
        # Get trip
        trip = get_object_or_404(Trip, id=trip_id)
        
        # Get trip transactions
        transactions = Transaction.objects.filter(
            trip=trip
        ).select_related('product', 'product__category').order_by('transaction_date')
        
        # Calculate totals
        total_revenue = 0
        total_cogs = 0
        
        # Prepare transaction data
        transaction_data = []
        for transaction in transactions:
            revenue = safe_float(transaction.quantity) * safe_float(transaction.unit_price)
            cost_per_unit = safe_float(transaction.product.purchase_price) if transaction.product else safe_float(transaction.unit_price * 0.7)
            cogs = safe_float(transaction.quantity) * cost_per_unit
            profit = revenue - cogs
                        
            total_revenue += revenue
            total_cogs += cogs
            
            # Format data with number translation
            formatted_data = [
                transaction.product.name if transaction.product else 'N/A',
                translate_numbers_to_arabic(transaction.product.item_id, language) if transaction.product else 'N/A',
                round(safe_float(transaction.quantity), 3),
                round(safe_float(transaction.unit_price), 3),
                round(cost_per_unit, 3),
                round(revenue, 3),
                round(cogs, 3),
                round(profit, 3),
                transaction.notes or ''
            ]
            
            transaction_data.append(formatted_data)
        
        total_profit = total_revenue - total_cogs
        
        # Generate filename
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename_base = f"trip_{trip.trip_number}_{timestamp}"
        
        # Determine trip status with translation
        trip_status = labels['completed'] if getattr(trip, 'is_completed', False) else labels['pending']
        
        # Get vessel name in appropriate language
        vessel_name = get_vessel_name_by_language(trip.vessel, language)
        
        # Get transaction date
        local_dt = timezone.localtime(transaction.created_at).replace(tzinfo=None)
        
        # Translated metadata with number conversion
        metadata = {
            labels['export_date']: format_datetime_for_language(datetime.now(), language),
            labels['trip_number']: translate_numbers_to_arabic(str(trip.trip_number), language),
            labels['vessel']: vessel_name,
            labels['trip_date']: format_datetime_for_language(local_dt, language),
            labels['status']: trip_status,
            labels['passengers']: translate_numbers_to_arabic(str(safe_int(getattr(trip, 'passenger_count', 0))), language),
            labels['currency']: labels['jod'],
            labels['total_revenue_jod']: translate_numbers_to_arabic(f"{round(total_revenue, 3)}", language),
            labels['total_cogs_jod']: translate_numbers_to_arabic(f"{round(total_cogs, 3)}", language),
            labels['total_profit_jod']: translate_numbers_to_arabic(f"{round(total_profit, 3)}", language),
            # labels['profit_margin']: translate_numbers_to_arabic(f"{round((total_profit/total_revenue*100) if total_revenue > 0 else 0, 0)}%", language),
            labels['generated_by']: request.user.username
        }
        
        # Translated headers
        headers = [
            labels['product'], 
            labels['product_id'],
            labels['quantity'],
            labels['unit_selling_price_jod'],
            labels['cogs_per_unit_jod'],
            labels['revenue_jod'],
            labels['cogs_jod'],
            labels['profit_jod'],
            labels['notes']
        ]
        
        # Translated summary data with number conversion
        summary_data = {
            labels['total_items_sold']: translate_numbers_to_arabic(str(len(transaction_data)), language),
            labels['total_revenue_jod']: translate_numbers_to_arabic(f"{round(total_revenue, 3)}", language),
            labels['total_cogs_jod']: translate_numbers_to_arabic(f"{round(total_cogs, 3)}", language),
            labels['total_profit_jod']: translate_numbers_to_arabic(f"{round(total_profit, 3)}", language),
            # labels['profit_margin']: translate_numbers_to_arabic(f"{round((total_profit/total_revenue*100) if total_revenue > 0 else 0, 0)}%", language)
        }
        
        # Generate dynamic title
        trip_number_translated = translate_numbers_to_arabic(str(trip.trip_number), language)
        if language == 'ar':
            report_title = f"تقرير مبيعات رحلة {trip_number_translated}"
        else:
            report_title = f"Trip Sales {trip.trip_number} Report"
        
        if export_format == 'excel':
            try:
                exporter = ExcelExporter(title=report_title)
                
                # Add title with generation date
                generation_text = f"{labels['generated_on']} {format_datetime_for_language(datetime.now(), language)}"
                exporter.add_title(report_title, generation_text)
                exporter.add_metadata(metadata)
                exporter.add_headers(headers)
                exporter.add_data_rows(transaction_data)
                exporter.add_summary(summary_data)
                
                return exporter.get_response(f"{filename_base}.xlsx")
                
            except Exception as e:
                logger.error(f"Excel single trip export error: {e}")
                return JsonResponse({'success': False, 'error': f'Excel export failed: {str(e)}'})
        
        else:  # PDF - Simplified without CSS injection
            try:
                # Create context (no CSS injection needed)
                context = {
                    'title': report_title,
                    'metadata': metadata,
                    'tables': [{'title': f"{report_title} - {labels['transaction_details']}", 'id': 'trip_table', 'headers': headers, 'rows': transaction_data}],
                    'charts': [],
                    'summary_data': summary_data,
                    'orientation': 'landscape',
                    'language': language,  # This enables all RTL styling
                    'generation_date': format_datetime_for_language(datetime.now(), language),
                    'has_logo': False,
                    'generated_on_text': labels['generated_on'],
                    'report_info_text': labels['report_information'],
                    'summary_text': labels['summary'],
                    'company_logo_text': labels['company_logo'],
                    'no_data_text': labels['no_data_available'],
                }
                
                # Use template directly (no CSS injection)                
                template_name = 'frontend/exports/wide_report.html'
                html_string = render_to_string(template_name, context)
                
                html = weasyprint.HTML(string=html_string)
                
                buffer = io.BytesIO()
                html.write_pdf(target=buffer)
                buffer.seek(0)
                
                response = HttpResponse(content_type='application/pdf')
                response['Content-Disposition'] = f'attachment; filename="{filename_base}.pdf"'
                response['Content-Length'] = len(buffer.getvalue())
                response.write(buffer.getvalue())
                
                return response
                
            except Exception as e:
                logger.error(f"PDF single trip export error: {e}")
                return JsonResponse({'success': False, 'error': f'PDF export failed: {str(e)}'})
                
    except json.JSONDecodeError:
        return JsonResponse({'success': False, 'error': 'Invalid JSON data'})
    except Exception as e:
        logger.error(f"Single trip export error: {e}")
        return JsonResponse({'success': False, 'error': f'Export failed: {str(e)}'})

# ===============================================================================
# PURCHASE ORDER EXPORTS (LIST AND INDIVIDUAL)
# ===============================================================================

@login_required
@require_http_methods(["POST"])
def export_purchase_orders(request):
    """Export purchase orders list to Excel or PDF - Fixed with RTL support following individual export pattern"""
    try:
        data = json.loads(request.body)
        export_format = data.get('format', 'excel')
        
        # Get translated labels with language from request (for RTL support)
        labels = get_translated_labels(request, data)
        language = labels['language']
        
        # Get filters
        start_date, end_date = get_date_range_from_request(data)
        if not start_date or not end_date:
            return JsonResponse({'success': False, 'error': 'Invalid date range'})
            
        vessel_id = data.get('vessel_id')
        status = data.get('status')
        
        # Build query
        pos = PurchaseOrder.objects.select_related(
            'vessel', 'created_by'
        ).filter(
            po_date__gte=start_date,
            po_date__lte=end_date
        ).order_by('-po_date')
        
        # Apply filters
        if vessel_id:
            pos = pos.filter(vessel_id=vessel_id)
        if status:
            pos = pos.filter(status=status)
            
        # Prepare data
        table_data = []
        total_cost = 0
        total_items = 0
        
        for po in pos[:2000]:
            # Calculate PO total cost
            po_stats = Transaction.objects.filter(
                purchase_order=po,
                transaction_type='SUPPLY'
            ).aggregate(
                total_cost=Sum(F('quantity') * F('unit_price')),
                total_quantity=Sum('quantity'),
                transaction_count=Count('id')
            )
            
            cost = safe_float(po_stats['total_cost'])
            quantity = safe_int(po_stats['total_quantity'])
            transaction_count = safe_int(po_stats['transaction_count'])
            
            total_cost += cost
            total_items += quantity
            
            # Get vessel name in appropriate language
            vessel_name = get_vessel_name_by_language(po.vessel, language)
            
            # Determine PO status with translation
            po_status_key = 'completed' if getattr(po, 'is_completed', False) or getattr(po, 'status', '') == 'completed' else 'pending'
            po_status = labels[po_status_key]
            
            # Get current datetime for trip date metadata formatting
            local_dt = timezone.localtime(po.created_at).replace(tzinfo=None) if hasattr(po, 'created_at') else timezone.now().replace(tzinfo=None)
            
            formatted_data = [
                translate_numbers_to_arabic(str(po.po_number), language),
                vessel_name,
                format_date_for_language(local_dt, language),
                po_status,
                translate_numbers_to_arabic(str(quantity), language),
                translate_numbers_to_arabic(format_currency(cost, 3), language),
                translate_numbers_to_arabic(str(transaction_count), language),
                po.created_by.username if po.created_by else labels.get('system', 'System')
            ]
            table_data.append(formatted_data)
        
        # Generate filename
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename_base = f"purchase_orders_export_{timestamp}"
        
        # Get current datetime for metadata
        local_dt = timezone.localtime(timezone.now()).replace(tzinfo=None)
        
        # Metadata with translation
        metadata = {
            labels['export_date']: format_datetime_for_language(local_dt, language),
            labels['period']: f"{format_date_for_language(start_date, language)} - {format_date_for_language(end_date, language)}",
            labels['total_pos']: translate_numbers_to_arabic(str(len(table_data)), language),
            labels['total_cost_jod']: translate_numbers_to_arabic(format_currency(total_cost, 3), language),
            labels['currency']: labels['jod'],  # Apply new currency pattern
            labels['total_items_received']: translate_numbers_to_arabic(str(total_items), language),
            labels['generated_by']: request.user.username
        }
        
        # Headers with translation
        headers = [
            labels['po_number'],
            labels['vessel'],
            labels['po_date'],
            labels['status'],
            labels['total_quantity'],
            labels['total_cost_jod'],
            labels.get('transactions', 'Transactions'),
            labels['generated_by']
        ]
        
        # Summary data with translation
        summary_data = {
            labels['total_pos']: translate_numbers_to_arabic(str(len(table_data)), language),
            labels['total_cost_jod']: translate_numbers_to_arabic(format_currency(total_cost, 3), language),
            labels['total_items_received']: translate_numbers_to_arabic(str(total_items), language),
        }
        
        # Generate report title with translation
        if language == 'ar':
            report_title = labels['purchase_order_supply_report']
        else:
            report_title = labels['purchase_order_supply_report']
        
        if export_format == 'excel':
            try:
                exporter = ExcelExporter(title=report_title)
                
                generation_text = f"{labels['generated_on']} {format_datetime_for_language(datetime.now(), language)}"
                exporter.add_title(report_title, generation_text)
                exporter.add_metadata(metadata)
                exporter.add_headers(headers)
                exporter.add_data_rows(table_data)
                exporter.add_summary(summary_data)
                
                return exporter.get_response(f"{filename_base}.xlsx")
                
            except Exception as e:
                logger.error(f"Excel PO export error: {e}")
                return JsonResponse({'success': False, 'error': f'Excel export failed: {str(e)}'})
        
        else:  # PDF - Use the SAME pattern as working individual exports
            try:
                # Create context manually like the working individual exports
                context = {
                    'title': report_title,
                    'metadata': metadata,
                    'tables': [{'title': f"{report_title} - {labels.get('pos_overview', 'Purchase Orders Overview')}", 'id': 'pos_table', 'headers': headers, 'rows': table_data}],
                    'summary_data': summary_data,
                    'orientation': 'landscape',
                    'language': language,  # KEY: This enables RTL
                    'generation_date': format_datetime_for_language(datetime.now(), language),
                    'has_logo': False,
                    'generated_on_text': labels['generated_on'],
                    'report_info_text': labels['report_information'],
                    'summary_text': labels['summary'],
                    'company_logo_text': labels['company_logo'],
                    'no_data_text': labels['no_data_available'],
                }
                
                # Use the same pattern as working individual exports
                template_name = 'frontend/exports/wide_report.html'
                html_string = render_to_string(template_name, context)
                
                html = weasyprint.HTML(string=html_string)
                
                buffer = io.BytesIO()
                html.write_pdf(target=buffer)
                buffer.seek(0)
                
                response = HttpResponse(content_type='application/pdf')
                response['Content-Disposition'] = f'attachment; filename="{filename_base}.pdf"'
                response['Content-Length'] = len(buffer.getvalue())
                response.write(buffer.getvalue())
                
                return response
                
            except Exception as e:
                logger.error(f"PDF PO export error: {e}")
                return JsonResponse({'success': False, 'error': f'PDF export failed: {str(e)}'})
                
    except json.JSONDecodeError:
        return JsonResponse({'success': False, 'error': 'Invalid JSON data'})
    except Exception as e:
        logger.error(f"PO export error: {e}")
        return JsonResponse({'success': False, 'error': f'Export failed: {str(e)}'})

@login_required
@require_http_methods(["POST"])
def export_single_po(request, po_id):
    """Export individual purchase order with enhanced financial verification features"""
    try:
        data = json.loads(request.body)
        export_format = data.get('format', 'excel')
        
        # Get translated labels with language from request
        labels = get_translated_labels(request, data)
        language = labels['language']
        
        # Get PO with related data
        po = get_object_or_404(PurchaseOrder, id=po_id)
        
        # Get PO transactions (supply transactions)
        transactions = Transaction.objects.filter(
            purchase_order=po,
            transaction_type='SUPPLY'
        ).select_related('product', 'product__category').order_by('transaction_date')
        
        # Calculate total cost and prepare enhanced transaction data
        total_cost = 0
        total_quantity = 0
        transaction_data = []
        verification_alerts = []
        
        for transaction in transactions:
            cost = safe_float(transaction.quantity) * safe_float(transaction.unit_price)
            total_cost += cost
            total_quantity += safe_float(transaction.quantity)
            
            # Smart cost verification - compare with product default
            product_default_cost = safe_float(transaction.product.purchase_price) if transaction.product else 0
            unit_cost = safe_float(transaction.unit_price)
            cost_status = "✓ Normal"
            
            if product_default_cost > 0:
                variance_pct = ((unit_cost - product_default_cost) / product_default_cost) * 100
                
                if variance_pct > 20:
                    cost_status = f"⚠ High Cost (+{variance_pct:.1f}%)"
                    verification_alerts.append(f"{transaction.product.name}: Unit cost {unit_cost:.3f} JOD is {variance_pct:.1f}% above standard ({product_default_cost:.3f} JOD)")
                elif variance_pct < -20:
                    cost_status = f"⚠ Low Cost ({variance_pct:.1f}%)"
                    verification_alerts.append(f"{transaction.product.name}: Unit cost {unit_cost:.3f} JOD is {abs(variance_pct):.1f}% below standard ({product_default_cost:.3f} JOD)")
            
            # Enhanced transaction data with verification info
            formatted_data = [
                format_datetime_for_language(transaction.transaction_date, language),
                transaction.product.name if transaction.product else 'N/A',
                translate_numbers_to_arabic(transaction.product.item_id, language) if transaction.product else 'N/A',
                f"{round(safe_float(transaction.quantity), 0)} units total",
                f"{round(unit_cost, 3)} JOD per unit", 
                f"{round(cost, 3)} JOD",
                cost_status,
                transaction.notes or ''
            ]
            
            transaction_data.append(formatted_data)
        
        # Generate filename
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename_base = f"po_verification_{po.po_number}_{timestamp}"
        
        # Determine PO status with translation
        po_status = labels['completed'] if getattr(po, 'is_completed', False) else labels['pending']
        
        # Get vessel name in appropriate language
        vessel_name = get_vessel_name_by_language(po.vessel, language)
        
        # Enhanced metadata for verification
        metadata = {
            'Export Date': format_datetime_for_language(datetime.now(), language),
            'PO Number': translate_numbers_to_arabic(str(po.po_number), language),
            'Vessel': vessel_name,
            'PO Date': format_date_for_language(po.po_date, language),
            'Status': po_status,
            'Total Cost': f"{total_cost:.3f} JOD",
            'Total Items': f"{len(transaction_data)} products",
            'Total Quantity': f"{total_quantity:.0f} units",
            'Average Cost per Unit': f"{(total_cost / total_quantity) if total_quantity > 0 else 0:.3f} JOD",
            'Verification Alerts': f"{len(verification_alerts)} items flagged" if verification_alerts else "All items within normal range",
            'Generated By': request.user.username
        }
        
        # Enhanced headers for verification
        headers = [
            'Time',
            'Product', 
            'Product ID',
            'Quantity',
            'Unit Cost',
            'Invoice Amount',
            'Verification Status',
            'Notes'
        ]
        
        # Enhanced summary with verification data
        summary_data = {
            'Total Products': str(len(transaction_data)),
            'Total Quantity': f"{total_quantity:.0f} units",
            'Total Cost': f"{total_cost:.3f} JOD",
            'Average Cost per Unit': f"{(total_cost / total_quantity) if total_quantity > 0 else 0:.3f} JOD",
            'Verification Status': f"{len(verification_alerts)} alerts" if verification_alerts else "All items normal"
        }
        
        # Generate dynamic title
        po_number_translated = translate_numbers_to_arabic(str(po.po_number), language)
        if language == 'ar':
            report_title = f"تقرير التحقق من أمر الشراء {po_number_translated}"
        else:
            report_title = f"PO {po.po_number} Verification Report"
        
        if export_format == 'excel':
            try:
                exporter = ExcelExporter(title=report_title)
                
                # Add title with generation date
                generation_text = f"Generated on {format_datetime_for_language(datetime.now(), language)}"
                exporter.add_title(report_title, generation_text)
                
                # Add metadata section
                exporter.add_metadata(metadata)
                
                # Add main transaction data
                exporter.add_headers(headers)
                exporter.add_data_rows(transaction_data)
                
                # Add summary
                exporter.add_summary(summary_data)
                
                # Add verification checklist as text
                checklist_title = "=== FINANCE DEPARTMENT CHECKLIST ==="
                verification_checklist = [
                    "□ Invoice amount matches system total ({:.3f} JOD)".format(total_cost),
                    "□ Product quantities verified against physical count",
                    "□ Unit costs reviewed and approved",
                    "□ All verification alerts investigated and resolved",
                    "□ Supplier invoice attached to this report",
                    "□ Journal entry created in accounting system",
                    "",
                    "Completed by: _____________ Date: _______",
                    "Reviewed by: _____________ Date: _______",
                    "Approved by: _____________ Date: _______"
                ]
                
                # Add checklist (using existing add_summary method)
                checklist_data = {item: "" for item in verification_checklist}
                exporter.add_summary(checklist_data, title=checklist_title)
                
                # Add alerts if any
                if verification_alerts:
                    alerts_data = {f"⚠ {alert}": "" for alert in verification_alerts}
                    exporter.add_summary(alerts_data, title="=== REVIEW ALERTS ===")
                
                return exporter.get_response(f"{filename_base}.xlsx")
                
            except Exception as e:
                logger.error(f"Excel single PO verification export error: {e}")
                return JsonResponse({'success': False, 'error': f'Excel export failed: {str(e)}'})
        
        else:  # PDF - Use existing template with enhanced context
            try:
                # Create enhanced context for verification PDF
                context = {
                    'title': report_title,
                    'metadata': metadata,
                    'tables': [
                        {
                            'title': f"{report_title} - Financial Verification",
                            'id': 'po_verification_table',
                            'headers': headers,
                            'rows': transaction_data
                        }
                    ],
                    'verification_alerts': verification_alerts if verification_alerts else ["✓ No cost variance alerts - all items within normal pricing range"],
                    'summary_data': summary_data,
                    'orientation': 'portrait',
                    'language': language,
                    'generation_date': format_datetime_for_language(datetime.now(), language),
                    'has_logo': False,
                    'is_verification_report': True,  # Flag for template
                    'total_cost_for_checklist': total_cost,
                    'generated_on_text': 'Generated on',
                    'report_info_text': 'Report Information',
                    'summary_text': 'Financial Summary', 
                    'verification_text': 'Verification Status',
                    'company_logo_text': 'COMPANY LOGO',
                    'no_data_text': 'No data available'
                }
                
                # Use standard template (enhanced with verification context)
                template_name = 'frontend/exports/po_verification_report.html'
                html_string = render_to_string(template_name, context)
                
                html = weasyprint.HTML(string=html_string)
                
                buffer = io.BytesIO()
                html.write_pdf(target=buffer)
                buffer.seek(0)
                
                response = HttpResponse(content_type='application/pdf')
                response['Content-Disposition'] = f'attachment; filename="{filename_base}.pdf"'
                response['Content-Length'] = len(buffer.getvalue())
                response.write(buffer.getvalue())
                
                return response
                
            except Exception as e:
                logger.error(f"PDF single PO verification export error: {e}")
                return JsonResponse({'success': False, 'error': f'PDF export failed: {str(e)}'})
                
    except json.JSONDecodeError:
        return JsonResponse({'success': False, 'error': 'Invalid JSON data'})
    except Exception as e:
        logger.error(f"Single PO verification export error: {e}")
        return JsonResponse({'success': False, 'error': f'Export failed: {str(e)}'})

# ===============================================================================
# MONTHLY REPORT EXPORTS
# ===============================================================================

@login_required
@require_http_methods(["POST"])
def export_monthly_report(request):
    """Export monthly performance report with transfer tracking - FIXED VERSION"""
    try:
        data = json.loads(request.body)
        export_format = data.get('format', 'excel')
        
        # Get month and year
        selected_month = safe_int(data.get('month'), datetime.now().month)
        selected_year = safe_int(data.get('year'), datetime.now().year)
        
        # Validate month
        if not (1 <= selected_month <= 12):
            return JsonResponse({'success': False, 'error': 'Invalid month'})
        
        # Calculate date range
        start_date = datetime(selected_year, selected_month, 1).date()
        if selected_month == 12:
            end_date = datetime(selected_year + 1, 1, 1).date() - timedelta(days=1)
        else:
            end_date = datetime(selected_year, selected_month + 1, 1).date() - timedelta(days=1)
        
        month_name = calendar.month_name[selected_month]
        
        # Calculate performance for each vessel for the month
        vessels = Vessel.objects.filter(active=True)
        vessel_performance = []
        monthly_revenue = 0
        monthly_costs = 0
        monthly_transfer_out = 0
        monthly_transfer_in = 0
        
        for vessel in vessels:
            # Get sales (revenue) for the month
            sales = Transaction.objects.filter(
                vessel=vessel,
                transaction_type='SALE',
                transaction_date__gte=start_date,
                transaction_date__lte=end_date
            ).aggregate(
                revenue=Sum(F('quantity') * F('unit_price')),
                count=Count('id')
            )
            
            # Get supplies (costs) for the month
            supplies = Transaction.objects.filter(
                vessel=vessel,
                transaction_type='SUPPLY',
                transaction_date__gte=start_date,
                transaction_date__lte=end_date
            ).aggregate(
                costs=Sum(F('quantity') * F('unit_price')),
                count=Count('id')
            )
            
            # Get transfers for the month
            transfer_out = Transaction.objects.filter(
                vessel=vessel,
                transaction_type='TRANSFER_OUT',
                transaction_date__gte=start_date,
                transaction_date__lte=end_date
            ).aggregate(
                total=Sum(F('quantity') * F('unit_price'))
            )
            
            transfer_in = Transaction.objects.filter(
                vessel=vessel,
                transaction_type='TRANSFER_IN',
                transaction_date__gte=start_date,
                transaction_date__lte=end_date
            ).aggregate(
                total=Sum(F('quantity') * F('unit_price'))
            )
            
            revenue = safe_float(sales['revenue'])
            costs = safe_float(supplies['costs'])
            transfer_out_total = safe_float(transfer_out['total'])
            transfer_in_total = safe_float(transfer_in['total'])
            profit = revenue - costs
            profit_margin = (profit / revenue * 100) if revenue > 0 else 0
            
            monthly_revenue += revenue
            monthly_costs += costs
            monthly_transfer_out += transfer_out_total
            monthly_transfer_in += transfer_in_total
            
            vessel_performance.append([
                vessel.name,
                format_currency(revenue, 3),
                format_currency(costs, 3),
                format_currency(profit, 3),
                format_percentage(profit_margin),
                safe_int(sales['count']),
                safe_int(supplies['count']),
                format_currency(transfer_out_total, 3),
                format_currency(transfer_in_total, 3)
            ])
        
        monthly_profit = monthly_revenue - monthly_costs
        
        # Generate filename
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename_base = f"monthly_report_{selected_year}_{selected_month:02d}_{timestamp}"
        
        # Metadata
        metadata = {
            'Report Period': f"{month_name} {selected_year}",
            'Export Date': datetime.now().strftime('%d/%m/%Y %H:%M'),
            'Date Range': f"{format_date(start_date)} to {format_date(end_date)}",
            'Total Revenue (JOD)': format_currency(monthly_revenue, 3),
            'Total Costs (JOD)': format_currency(monthly_costs, 3),
            'Total Profit (JOD)': format_currency(monthly_profit, 3),
            'Total Transfer Out (JOD)': format_currency(monthly_transfer_out, 3),
            'Total Transfer In (JOD)': format_currency(monthly_transfer_in, 3),
            'Overall Profit Margin': format_percentage((monthly_profit / monthly_revenue * 100) if monthly_revenue > 0 else 0),
            'Generated By': request.user.username
        }
        
        headers = [
            'Vessel', 'Revenue (JOD)', 'Costs (JOD)', 'Profit (JOD)', 
            'Profit Margin (%)', 'Sales Count', 'Supply Count',
            'Transfer Out (JOD)', 'Transfer In (JOD)'
        ]
        
        # Create summary data 
        summary_data = {
            'Total Vessels': len(vessel_performance),
            'Total Revenue (JOD)': format_currency(monthly_revenue, 3),
            'Total Profit (JOD)': format_currency(monthly_profit, 3),
            'Overall Profit Margin': format_percentage((monthly_profit / monthly_revenue * 100) if monthly_revenue > 0 else 0),
            'Net Transfers': format_currency(monthly_transfer_out - monthly_transfer_in, 3)
        }
        
        if export_format == 'excel':
            try:
                exporter = ExcelExporter(title="Monthly Report")
                exporter.add_title(f"Monthly Report - {month_name} {selected_year}", f"Generated on {datetime.now().strftime('%d/%m/%Y %H:%M')}")
                exporter.add_metadata(metadata)
                exporter.add_headers(headers)
                exporter.add_data_rows(vessel_performance)
                exporter.add_summary(summary_data)
                
                return exporter.get_response(f"{filename_base}.xlsx")
                
            except Exception as e:
                logger.error(f"Excel monthly report export error: {e}")
                return JsonResponse({'success': False, 'error': f'Excel export failed: {str(e)}'})
        
        else:  # PDF
            try:
                exporter = create_weasy_exporter_for_data("Monthly Report", "normal")
                exporter.add_metadata(metadata)
                exporter.add_table(headers, vessel_performance, table_title=f"Monthly Performance - {month_name} {selected_year}")
                exporter.add_summary(summary_data)
                
                return exporter.get_response(f"{filename_base}.pdf")
                
            except Exception as e:
                logger.error(f"PDF monthly report export error: {e}")
                return JsonResponse({'success': False, 'error': f'PDF export failed: {str(e)}'})
                
    except json.JSONDecodeError:
        return JsonResponse({'success': False, 'error': 'Invalid JSON data'})
    except Exception as e:
        logger.error(f"Monthly report export error: {e}")
        return JsonResponse({'success': False, 'error': f'Export failed: {str(e)}'})

# ===============================================================================
# DAILY REPORT EXPORTS
# ===============================================================================

@login_required
@require_http_methods(["POST"])
def export_daily_report(request):
    """Export daily performance report - FIXED VERSION"""
    try:
        data = json.loads(request.body)
        export_format = data.get('format', 'excel')
        
        # Get date
        selected_date = data.get('date')
        if selected_date:
            selected_date = datetime.strptime(selected_date, '%Y-%m-%d').date()
        else:
            selected_date = timezone.now().date()
        
        # Calculate performance for each vessel for the selected day
        vessels = Vessel.objects.filter(active=True)
        vessel_performance = []
        daily_revenue = 0
        daily_costs = 0
        
        for vessel in vessels:
            # Get sales (revenue) for the day
            sales = Transaction.objects.filter(
                vessel=vessel,
                transaction_type='SALE',
                transaction_date=selected_date
            ).aggregate(
                revenue=Sum(F('quantity') * F('unit_price')),
                count=Count('id')
            )
            
            # Get supplies (costs) for the day
            supplies = Transaction.objects.filter(
                vessel=vessel,
                transaction_type='SUPPLY',
                transaction_date=selected_date
            ).aggregate(
                costs=Sum(F('quantity') * F('unit_price')),
                count=Count('id')
            )
            
            revenue = safe_float(sales['revenue'])
            costs = safe_float(supplies['costs'])
            profit = revenue - costs
            profit_margin = (profit / revenue * 100) if revenue > 0 else 0
            
            # Only include vessels with activity
            if revenue > 0 or costs > 0:
                daily_revenue += revenue
                daily_costs += costs
                
                vessel_performance.append([
                    vessel.name,
                    format_currency(revenue, 3),
                    format_currency(costs, 3),
                    format_currency(profit, 3),
                    format_percentage(profit_margin),
                    safe_int(sales['count']),
                    safe_int(supplies['count'])
                ])
        
        daily_profit = daily_revenue - daily_costs
        
        # Generate filename
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename_base = f"daily_report_{selected_date.strftime('%Y%m%d')}_{timestamp}"
        
        # Metadata
        metadata = {
            'Report Date': format_date(selected_date),
            'Export Date': datetime.now().strftime('%d/%m/%Y %H:%M'),
            'Total Revenue (JOD)': format_currency(daily_revenue, 3),
            'Total Costs (JOD)': format_currency(daily_costs, 3),
            'Total Profit (JOD)': format_currency(daily_profit, 3),
            'Overall Profit Margin': format_percentage((daily_profit / daily_revenue * 100) if daily_revenue > 0 else 0),
            'Generated By': request.user.username
        }
        
        headers = [
            'Vessel', 'Revenue (JOD)', 'Costs (JOD)', 'Profit (JOD)', 
            'Profit Margin (%)', 'Sales Count', 'Supply Count'
        ]
        
        # Create summary data
        summary_data = {
            'Active Vessels': len(vessel_performance),
            'Total Revenue (JOD)': format_currency(daily_revenue, 3),
            'Total Profit (JOD)': format_currency(daily_profit, 3),
            'Overall Profit Margin': format_percentage((daily_profit / daily_revenue * 100) if daily_revenue > 0 else 0)
        }
        
        if export_format == 'excel':
            try:
                exporter = ExcelExporter(title="Daily Report")
                exporter.add_title(f"Daily Report - {format_date(selected_date)}", f"Generated on {datetime.now().strftime('%d/%m/%Y %H:%M')}")
                exporter.add_metadata(metadata)
                exporter.add_headers(headers)
                exporter.add_data_rows(vessel_performance)
                exporter.add_summary(summary_data)
                
                return exporter.get_response(f"{filename_base}.xlsx")
                
            except Exception as e:
                logger.error(f"Excel daily report export error: {e}")
                return JsonResponse({'success': False, 'error': f'Excel export failed: {str(e)}'})
        
        else:  # PDF
            try:
                exporter = create_weasy_exporter_for_data("Daily Report", "normal")
                exporter.add_metadata(metadata)
                exporter.add_table(headers, vessel_performance, table_title=f"Daily Performance - {format_date(selected_date)}")
                exporter.add_summary(summary_data)
                
                return exporter.get_response(f"{filename_base}.pdf")
                
            except Exception as e:
                logger.error(f"PDF daily report export error: {e}")
                return JsonResponse({'success': False, 'error': f'PDF export failed: {str(e)}'})
                
    except json.JSONDecodeError:
        return JsonResponse({'success': False, 'error': 'Invalid JSON data'})
    except Exception as e:
        logger.error(f"Daily report export error: {e}")
        return JsonResponse({'success': False, 'error': f'Export failed: {str(e)}'})

# ===============================================================================
# ANALYTICS EXPORT
# ===============================================================================

@login_required
@require_http_methods(["POST"])
def export_analytics(request):
    """Export analytics report with performance metrics and charts"""
    try:
        data = json.loads(request.body)
        export_format = data.get('format', 'excel')
        
        # Get date range (default to last 30 days)
        end_date = timezone.now().date()
        start_date = end_date - timedelta(days=30)
        
        # Override with request data if provided
        if data.get('start_date'):
            start_date = datetime.strptime(data.get('start_date'), '%Y-%m-%d').date()
        if data.get('end_date'):
            end_date = datetime.strptime(data.get('end_date'), '%Y-%m-%d').date()
        
        # Calculate comprehensive analytics for each vessel
        vessels = Vessel.objects.filter(active=True)
        vessel_analytics = []
        total_revenue = 0
        total_costs = 0
        total_pos = 0
        po_analytics = []
        
        for vessel in vessels:
            # Get sales data
            sales_stats = Transaction.objects.filter(
                vessel=vessel,
                transaction_type='SALE',
                transaction_date__gte=start_date,
                transaction_date__lte=end_date
            ).aggregate(
                revenue=Sum(F('quantity') * F('unit_price')),
                sales_count=Count('id')
            )
            
            # Get supply data
            supply_stats = Transaction.objects.filter(
                vessel=vessel,
                transaction_type='SUPPLY',
                transaction_date__gte=start_date,
                transaction_date__lte=end_date
            ).aggregate(
                costs=Sum(F('quantity') * F('unit_price')),
                supply_count=Count('id')
            )
            
            # Get PO data
            po_stats = PurchaseOrder.objects.filter(
                vessel=vessel,
                po_date__gte=start_date,
                po_date__lte=end_date
            ).aggregate(
                po_count=Count('id')
            )
            
            # Calculate PO costs from related transactions
            po_cost = Transaction.objects.filter(
                vessel=vessel,
                transaction_type='SUPPLY',
                transaction_date__gte=start_date,
                transaction_date__lte=end_date,
                purchase_order__isnull=False
            ).aggregate(
                total=Sum(F('quantity') * F('unit_price'))
            )['total'] or 0
            
            revenue = safe_float(sales_stats['revenue'])
            costs = safe_float(supply_stats['costs'])
            profit_margin = ((revenue - costs) / revenue * 100) if revenue > 0 else 0
            avg_transaction = revenue / safe_int(sales_stats['sales_count']) if safe_int(sales_stats['sales_count']) > 0 else 0
            
            total_revenue += revenue
            total_costs += costs
            total_pos += safe_int(po_stats['po_count'])
            
            # Only include vessels with activity
            if revenue > 0 or costs > 0 or po_cost > 0:
                vessel_analytics.append([
                    vessel.name,
                    revenue,  # Store as number, not formatted string
                    costs,    # Store as number, not formatted string
                    profit_margin,  # Store as number, not formatted string
                    safe_int(sales_stats['sales_count']),
                    avg_transaction,  # Store as number
                    safe_int(po_stats['po_count']),
                    po_cost   # Store as number
                ])
                
                # For PO chart data
                if po_cost > 0:
                    po_analytics.append((vessel.name[:15], po_cost))
        
        # Sort by revenue (descending)
        vessel_analytics.sort(key=lambda x: float(x[1]), reverse=True)
        
        total_profit = total_revenue - total_costs
        
        # Calculate additional statistics
        total_stats = Transaction.objects.filter(
            transaction_date__gte=start_date,
            transaction_date__lte=end_date
        ).aggregate(
            transaction_count=Count('id')
        )
        
        # Generate filename
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename_base = f"analytics_report_{timestamp}"
        
        # Metadata
        metadata = {
            'Analysis Period': f"{format_date(start_date)} to {format_date(end_date)}",
            'Total Revenue (JOD)': format_currency(total_revenue, 3),
            'Total Costs (JOD)': format_currency(total_costs, 3),
            'Total Profit (JOD)': format_currency(total_profit, 3),
            'Total Transactions': safe_int(total_stats['transaction_count']),
            'Total Purchase Orders': total_pos,
            'Average Daily Revenue (JOD)': format_currency((total_revenue / (end_date - start_date).days), 3),
            'Overall Profit Margin': format_percentage((total_profit / total_revenue * 100) if total_revenue > 0 else 0),
            'Generated By': request.user.username
        }
        
        headers = [
            'Vessel', 'Revenue (JOD)', 'Costs (JOD)', 'Profit Margin (%)', 
            'Sales Count', 'Avg Transaction Value (JOD)', 'PO Count', 'PO Total Cost (JOD)'
        ]
        
        # Create summary data
        summary_data = {
            'Analysis Period': f"{(end_date - start_date).days} days",
            'Total Revenue (JOD)': format_currency(total_revenue, 3),
            'Overall Profit Margin': format_percentage((total_profit / total_revenue * 100) if total_revenue > 0 else 0),
            'Best Performing Vessel': vessel_analytics[0][0] if vessel_analytics else None,
            'Total Purchase Orders': total_pos
        }
        
        if export_format == 'excel':
            try:
                exporter = ExcelExporter(title="Analytics Report")
                exporter.add_title("Analytics Report", f"Generated on {datetime.now().strftime('%d/%m/%Y %H:%M')}")
                exporter.add_metadata(metadata)
                exporter.add_headers(headers)
                exporter.add_data_rows(vessel_analytics)  # Now contains raw numbers
                exporter.add_summary(summary_data)
                
                return exporter.get_response(f"{filename_base}.xlsx")
                
            except Exception as e:
                logger.error(f"Excel analytics export error: {e}")
                return JsonResponse({'success': False, 'error': f'Excel export failed: {str(e)}'})
        
        else:  # PDF - Now landscape with charts
            try:
                exporter = create_weasy_exporter(title="Analytics Report", template_type="analytics", orientation="landscape")
                exporter.add_metadata(metadata)
                
                # Add charts for analytics
                if vessel_analytics:
                    try:
                        # Revenue chart - use raw numbers
                        revenue_data = [(row[0][:15], float(row[1])) for row in vessel_analytics[:8]]
                        if revenue_data:
                            exporter.add_chart(revenue_data, 'bar', 'Revenue by Vessel (JOD)', 'revenue_chart')
                        
                        # Profit margin chart - use raw numbers  
                        profit_data = [(row[0][:15], float(row[3])) for row in vessel_analytics[:8]]
                        if profit_data:
                            exporter.add_chart(profit_data, 'bar', 'Profit Margin by Vessel (%)', 'profit_chart')
                        
                        # Add PO chart
                        if po_analytics:
                            # Sort PO data by cost (descending) and take top 8
                            po_analytics.sort(key=lambda x: x[1], reverse=True)
                            po_chart_data = po_analytics[:8]
                            exporter.add_chart(po_chart_data, 'bar', 'Purchase Order Costs by Vessel (JOD)', 'po_chart')
                            
                    except Exception as chart_error:
                        logger.warning(f"Could not create charts for analytics: {chart_error}")
                
                # Format data for PDF display
                formatted_vessel_analytics = []
                for row in vessel_analytics:
                    formatted_row = [
                        row[0],  # Vessel name
                        format_currency(row[1], 3),  # Revenue
                        format_currency(row[2], 3),  # Costs
                        format_percentage(row[3]),   # Profit margin
                        row[4],  # Sales count
                        format_currency(row[5], 3),  # Avg transaction
                        row[6],  # PO count
                        format_currency(row[7], 3)   # PO cost
                    ]
                    formatted_vessel_analytics.append(formatted_row)
                
                exporter.add_table(headers, formatted_vessel_analytics, table_title="Vessel Performance Analytics")
                exporter.add_summary(summary_data)
                
                return exporter.get_response(f"{filename_base}.pdf")
                
            except Exception as e:
                logger.error(f"PDF analytics export error: {e}")
                return JsonResponse({'success': False, 'error': f'PDF export failed: {str(e)}'})
                
    except json.JSONDecodeError:
        return JsonResponse({'success': False, 'error': 'Invalid JSON data'})
    except Exception as e:
        logger.error(f"Analytics export error: {e}")
        return JsonResponse({'success': False, 'error': f'Export failed: {str(e)}'})